<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SYNIA Viewer</title>
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --synia-teal: #0099a8;
            --synia-teal-dark: #007a87;
            --synia-dark: #0d3d42;
            --synia-bg: #062a2e;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Assistant', sans-serif;
            background: var(--synia-bg);
            color: #eee;
            min-height: 100vh;
            padding: 12px;
            font-size: 1.1rem;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            height: calc(100vh - 24px);
            display: flex;
            flex-direction: column;
        }
        header {
            text-align: center;
            padding: 12px 0;
            border-bottom: 2px solid var(--synia-teal);
            margin-bottom: 12px;
            flex-shrink: 0;
        }
        .logo {
            max-height: 40px;
            margin-bottom: 8px;
        }
        h1 {
            font-size: 1.3rem;
            margin-bottom: 4px;
            font-weight: 600;
        }
        .status {
            font-size: 0.85rem;
            color: #888;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
        }
        .status-dot.connected {
            background: var(--synia-teal);
        }
        .status-dot.error {
            background: #ef4444;
        }
        .transcript {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 20px;
            -webkit-overflow-scrolling: touch;
        }
        .bubble {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 20px;
            word-wrap: break-word;
            line-height: 1.5;
        }
        /* My speech (foreign speaker) - right side, teal */
        .bubble.mine {
            align-self: flex-end;
            background: var(--synia-teal);
            color: white;
            border-bottom-right-radius: 6px;
        }
        /* Their speech (German) - left side, dark teal */
        .bubble.theirs {
            align-self: flex-start;
            background: var(--synia-dark);
            color: #eee;
            border-bottom-left-radius: 6px;
        }
        .bubble.live {
            opacity: 0.7;
        }
        .bubble.live.mine {
            border-right: 3px solid #fbbf24;
        }
        .bubble.live.theirs {
            border-left: 3px solid #fbbf24;
        }
        .bubble-source {
            font-weight: 500;
        }
        .ended-notice {
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: 0.9rem;
        }
        .ended-notice strong {
            display: block;
            color: #ef4444;
            margin-bottom: 4px;
        }
        /* Mic button */
        .mic-bar {
            flex-shrink: 0;
            padding: 12px 0;
            text-align: center;
        }
        .mic-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background: var(--synia-teal);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        .mic-btn:hover {
            background: var(--synia-teal-dark);
        }
        .mic-btn:active {
            transform: scale(0.95);
        }
        .mic-btn.recording {
            background: #ef4444;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
        }
        .mic-status {
            font-size: 0.75rem;
            color: #888;
            margin-top: 6px;
        }
        .lang-select {
            padding: 8px 12px;
            font-size: 0.95rem;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: var(--synia-dark);
            color: #eee;
            margin-bottom: 10px;
            font-family: 'Assistant', sans-serif;
            cursor: pointer;
            min-width: 180px;
        }
        .lang-select:focus {
            outline: 2px solid var(--synia-teal);
            outline-offset: 2px;
        }
        .mic-btn:disabled {
            background: #555;
            cursor: not-allowed;
            animation: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="/static/synia-logo.png" alt="SYNIA" class="logo">
            <div class="status" id="status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Connecting...</span>
            </div>
        </header>
        <div class="transcript" id="transcript"></div>
        <div class="mic-bar" id="micBar">
            <select class="lang-select" id="viewerLangSelect">
                <option value="" disabled selected>-- Your language --</option>
                <option value="en">English</option>
                <option value="fr">French</option>
                <option value="es">Spanish</option>
                <option value="it">Italian</option>
                <option value="pl">Polish</option>
                <option value="ro">Romanian</option>
                <option value="hr">Croatian</option>
                <option value="bg">Bulgarian</option>
                <option value="tr">Turkish</option>
                <option value="ru">Russian</option>
                <option value="uk">Ukrainian</option>
                <option value="hu">Hungarian</option>
                <option value="ar">Arabic</option>
                <option value="fa">Persian</option>
                <option value="sr">Serbian</option>
                <option value="sq">Albanian</option>
            </select>
            <br>
            <button class="mic-btn" id="micBtn" title="Start microphone" disabled>&#127908;</button>
            <div class="mic-status" id="micStatus">Select your language first</div>
        </div>
    </div>

    <script>
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const transcript = document.getElementById('transcript');
        const micBar = document.getElementById('micBar');
        const micBtn = document.getElementById('micBtn');
        const micStatus = document.getElementById('micStatus');
        const viewerLangSelect = document.getElementById('viewerLangSelect');

        // Language display names
        const LANG_NAMES = {
            'en': 'English', 'de': 'German', 'fr': 'French', 'es': 'Spanish',
            'it': 'Italian', 'pl': 'Polish', 'ro': 'Romanian', 'hr': 'Croatian',
            'bg': 'Bulgarian', 'sq': 'Albanian', 'tr': 'Turkish', 'ru': 'Russian',
            'uk': 'Ukrainian', 'hu': 'Hungarian', 'ar': 'Arabic', 'fa': 'Persian',
            'sr': 'Serbian'
        };

        let foreignLang = null;
        let segments = [];
        let ws = null;
        let sessionEnded = false;
        let sessionActive = false;

        // Mic capture state
        const SAMPLE_RATE = 16000;
        let micRecording = false;
        let audioContext = null;
        let mediaStream = null;
        let processor = null;

        // Get token from URL path
        const pathParts = window.location.pathname.split('/');
        const token = pathParts[pathParts.length - 1];

        function setStatus(text, type) {
            statusText.textContent = text;
            statusDot.className = 'status-dot ' + (type || '');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function renderSegments() {
            transcript.innerHTML = '';

            segments.forEach(seg => {
                const segLang = seg.src_lang;
                const translations = seg.translations || {};
                const isGermanSpeaker = (segLang === 'de');
                const liveClass = seg.final ? '' : ' live';

                // From foreign speaker's perspective:
                // - Their own speech (foreign) = "mine" (right, blue)
                // - German speaker = "theirs" (left, gray)
                const bubbleClass = isGermanSpeaker ? 'theirs' : 'mine';

                const div = document.createElement('div');
                div.className = 'bubble ' + bubbleClass + liveClass;
                div.dataset.id = seg.id;

                let html = '';

                if (isGermanSpeaker) {
                    // German speaker: show only the translation in foreign language
                    const translation = translations[foreignLang] || '';
                    if (translation) {
                        html = `<div class="bubble-source">${escapeHtml(translation)}</div>`;
                    } else {
                        html = `<div class="bubble-source" style="opacity:0.5">...</div>`;
                    }
                } else {
                    // Foreign speaker (me): show only my speech in my language
                    html = `<div class="bubble-source">${escapeHtml(seg.src)}</div>`;
                }

                div.innerHTML = html;
                transcript.appendChild(div);
            });

            // Auto-scroll to bottom - defer to ensure DOM is updated
            requestAnimationFrame(() => {
                transcript.scrollTop = transcript.scrollHeight;
            });
        }

        function updateSegments(newSegments) {
            segments = newSegments;
            renderSegments();
        }

        function updateTranslation(segmentId, tgtLang, text) {
            const seg = segments.find(s => s.id === segmentId);
            if (seg) {
                if (!seg.translations) seg.translations = {};
                seg.translations[tgtLang] = text;
                renderSegments();
            }
        }

        function showSessionEnded() {
            sessionEnded = true;
            setStatus('Session ended', 'error');

            const notice = document.createElement('div');
            notice.className = 'ended-notice';
            notice.innerHTML = '<strong>Session Ended</strong>The recording has stopped. This transcript is preserved for your review.';
            transcript.appendChild(notice);
            requestAnimationFrame(() => {
                transcript.scrollTop = transcript.scrollHeight;
            });
        }

        // Audio processing helpers (same as index.html)
        function downsampleBuffer(buffer, inputSampleRate, outputSampleRate) {
            if (inputSampleRate === outputSampleRate) return buffer;
            const ratio = inputSampleRate / outputSampleRate;
            const newLength = Math.round(buffer.length / ratio);
            const result = new Float32Array(newLength);
            for (let i = 0; i < newLength; i++) {
                const srcIndex = i * ratio;
                const srcIndexFloor = Math.floor(srcIndex);
                const srcIndexCeil = Math.min(srcIndexFloor + 1, buffer.length - 1);
                const t = srcIndex - srcIndexFloor;
                result[i] = buffer[srcIndexFloor] * (1 - t) + buffer[srcIndexCeil] * t;
            }
            return result;
        }

        function floatTo16BitPCM(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return int16Array.buffer;
        }

        async function startMicrophone() {
            if (!window.isSecureContext) {
                micStatus.textContent = 'Requires HTTPS';
                return;
            }
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                micStatus.textContent = 'Mic not supported';
                return;
            }

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: { channelCount: 1, sampleRate: { ideal: 48000 }, echoCancellation: true, noiseSuppression: true }
                });

                audioContext = new AudioContext({ sampleRate: 48000 });
                const source = audioContext.createMediaStreamSource(mediaStream);
                processor = audioContext.createScriptProcessor(4096, 1, 1);

                // Send viewer audio config with foreign language hint
                if (ws && ws.readyState === WebSocket.OPEN && foreignLang) {
                    ws.send(JSON.stringify({ type: 'viewer_audio_config', foreign_lang: foreignLang }));
                }

                processor.onaudioprocess = (e) => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        const downsampled = downsampleBuffer(inputData, audioContext.sampleRate, SAMPLE_RATE);
                        const pcm16 = floatTo16BitPCM(downsampled);
                        ws.send(pcm16);
                    }
                };

                source.connect(processor);
                processor.connect(audioContext.destination);

                micRecording = true;
                micBtn.classList.add('recording');
                viewerLangSelect.disabled = true;
                micStatus.textContent = 'Listening...';
            } catch (err) {
                console.error('Mic error:', err);
                micStatus.textContent = 'Mic access denied';
            }
        }

        function stopMicrophone() {
            if (processor) { processor.disconnect(); processor = null; }
            if (audioContext) { audioContext.close(); audioContext = null; }
            if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
            micRecording = false;
            micBtn.classList.remove('recording');
            viewerLangSelect.disabled = false;
            micStatus.textContent = 'Tap to speak';
        }

        function updateMicState() {
            // Mic requires both language selected and active session
            const canMic = sessionActive && viewerLangSelect.value;
            micBtn.disabled = !canMic;
            if (!viewerLangSelect.value) {
                micStatus.textContent = 'Select your language first';
            } else if (!sessionActive) {
                micStatus.textContent = 'Waiting for session...';
            } else {
                micStatus.textContent = 'Tap to speak';
            }
        }

        function onSessionActive() {
            sessionActive = true;
            // Pre-select language if server already knows it
            if (foreignLang && viewerLangSelect.querySelector(`option[value="${foreignLang}"]`)) {
                viewerLangSelect.value = foreignLang;
            }
            updateMicState();
        }

        function onSessionEnded() {
            sessionActive = false;
            stopMicrophone();
            updateMicState();
        }

        viewerLangSelect.addEventListener('change', () => {
            const selectedLang = viewerLangSelect.value;
            if (selectedLang) {
                foreignLang = selectedLang;
                // Re-render with correct language for translations
                renderSegments();
                // Send language hint to server immediately if connected
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'viewer_audio_config', foreign_lang: selectedLang }));
                }
            }
            updateMicState();
        });

        micBtn.addEventListener('click', () => {
            if (micRecording) {
                stopMicrophone();
            } else {
                if (!viewerLangSelect.value) {
                    micStatus.textContent = 'Select your language first';
                    return;
                }
                startMicrophone();
            }
        });

        function connect() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws/viewer/${token}`;

            setStatus('Connecting...', '');
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                setStatus('Connected', 'connected');
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);

                    if (data.type === 'init') {
                        if (data.status === 'waiting') {
                            setStatus('Waiting for session to start...', 'connected');
                        } else {
                            if (data.foreign_lang) foreignLang = data.foreign_lang;
                            updateSegments(data.segments || []);
                            setStatus('Live', 'connected');
                            onSessionActive();
                        }
                    } else if (data.type === 'session_active') {
                        if (data.foreign_lang) foreignLang = data.foreign_lang;
                        updateSegments(data.segments || []);
                        setStatus('Live', 'connected');
                        onSessionActive();
                    } else if (data.type === 'segments') {
                        if (data.foreign_lang && !foreignLang) {
                            foreignLang = data.foreign_lang;
                        }
                        updateSegments(data.segments || []);
                    } else if (data.type === 'translation') {
                        updateTranslation(data.segment_id, data.tgt_lang, data.text);
                    } else if (data.type === 'session_ended') {
                        onSessionEnded();
                        showSessionEnded();
                    } else if (data.type === 'ping') {
                        // Respond to ping with pong
                        ws.send(JSON.stringify({ type: 'pong' }));
                    }
                } catch (e) {
                    console.error('Parse error:', e);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                setStatus('Connection error', 'error');
            };

            ws.onclose = (event) => {
                stopMicrophone();
                if (!sessionEnded) {
                    if (event.code === 4004) {
                        setStatus('Invalid or expired link', 'error');
                    } else {
                        setStatus('Disconnected', 'error');
                        // Try to reconnect after 3 seconds
                        setTimeout(connect, 3000);
                    }
                }
            };
        }

        // Start connection
        connect();
    </script>
</body>
</html>
