<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SYNIA Viewer</title>
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --synia-teal: #0099a8;
            --synia-teal-dark: #007a87;
            --synia-dark: #0d3d42;
            --synia-bg: #062a2e;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Assistant', sans-serif;
            background: var(--synia-bg);
            color: #eee;
            min-height: 100vh;
            padding: 12px;
            font-size: 1.1rem;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            height: calc(100vh - 24px);
            display: flex;
            flex-direction: column;
        }
        header {
            text-align: center;
            padding: 12px 0;
            border-bottom: 2px solid var(--synia-teal);
            margin-bottom: 12px;
            flex-shrink: 0;
        }
        .logo {
            max-height: 40px;
            margin-bottom: 8px;
        }
        h1 {
            font-size: 1.3rem;
            margin-bottom: 4px;
            font-weight: 600;
        }
        .status {
            font-size: 0.85rem;
            color: #888;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
        }
        .status-dot.connected {
            background: var(--synia-teal);
        }
        .status-dot.error {
            background: #ef4444;
        }
        .transcript {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 20px;
            -webkit-overflow-scrolling: touch;
        }
        .bubble {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 20px;
            word-wrap: break-word;
            line-height: 1.5;
        }
        /* My speech (foreign speaker) - right side, teal */
        .bubble.mine {
            align-self: flex-end;
            background: var(--synia-teal);
            color: white;
            border-bottom-right-radius: 6px;
        }
        /* Their speech (German) - left side, dark teal */
        .bubble.theirs {
            align-self: flex-start;
            background: var(--synia-dark);
            color: #eee;
            border-bottom-left-radius: 6px;
        }
        .bubble.live {
            opacity: 0.7;
        }
        .bubble.live.mine {
            border-right: 3px solid #fbbf24;
        }
        .bubble.live.theirs {
            border-left: 3px solid #fbbf24;
        }
        .bubble-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
            margin-bottom: 4px;
        }
        .bubble-source {
            font-weight: 500;
        }
        .bubble-translation {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.2);
            font-size: 0.95rem;
            opacity: 0.85;
        }
        .bubble.theirs .bubble-translation {
            border-top-color: rgba(255,255,255,0.15);
        }
        .ended-notice {
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: 0.9rem;
        }
        .ended-notice strong {
            display: block;
            color: #ef4444;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="/static/synia-logo.png" alt="SYNIA" class="logo">
            <div class="status" id="status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Connecting...</span>
            </div>
        </header>
        <div class="transcript" id="transcript"></div>
    </div>

    <script>
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const transcript = document.getElementById('transcript');

        // Language display names
        const LANG_NAMES = {
            'en': 'English', 'de': 'German', 'fr': 'French', 'es': 'Spanish',
            'it': 'Italian', 'pl': 'Polish', 'ro': 'Romanian', 'hr': 'Croatian',
            'bg': 'Bulgarian', 'sq': 'Albanian', 'tr': 'Turkish', 'ru': 'Russian',
            'uk': 'Ukrainian', 'hu': 'Hungarian', 'ar': 'Arabic', 'fa': 'Persian',
            'sr': 'Serbian'
        };

        let foreignLang = null;
        let segments = [];
        let ws = null;
        let sessionEnded = false;

        // Get token from URL path
        const pathParts = window.location.pathname.split('/');
        const token = pathParts[pathParts.length - 1];

        function setStatus(text, type) {
            statusText.textContent = text;
            statusDot.className = 'status-dot ' + (type || '');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function renderSegments() {
            transcript.innerHTML = '';

            segments.forEach(seg => {
                const segLang = seg.src_lang;
                const translations = seg.translations || {};
                const isGermanSpeaker = (segLang === 'de');
                const liveClass = seg.final ? '' : ' live';

                // From foreign speaker's perspective:
                // - Their own speech (foreign) = "mine" (right, blue)
                // - German speaker = "theirs" (left, gray)
                const bubbleClass = isGermanSpeaker ? 'theirs' : 'mine';

                const div = document.createElement('div');
                div.className = 'bubble ' + bubbleClass + liveClass;
                div.dataset.id = seg.id;

                let html = '';

                if (isGermanSpeaker) {
                    // German speaker: show their German speech + translation to foreign
                    const label = 'German';
                    const translation = translations[foreignLang] || '';
                    html = `<div class="bubble-label">${label}</div>`;
                    html += `<div class="bubble-source">${escapeHtml(seg.src)}</div>`;
                    if (translation) {
                        html += `<div class="bubble-translation">${escapeHtml(translation)}</div>`;
                    }
                } else {
                    // Foreign speaker (me): show my speech + German translation
                    const label = LANG_NAMES[segLang] || segLang || 'You';
                    const translation = translations['de'] || '';
                    html = `<div class="bubble-label">${label}</div>`;
                    html += `<div class="bubble-source">${escapeHtml(seg.src)}</div>`;
                    if (translation) {
                        html += `<div class="bubble-translation">${escapeHtml(translation)}</div>`;
                    }
                }

                div.innerHTML = html;
                transcript.appendChild(div);
            });

            // Auto-scroll to bottom - defer to ensure DOM is updated
            requestAnimationFrame(() => {
                transcript.scrollTop = transcript.scrollHeight;
            });
        }

        function updateSegments(newSegments) {
            segments = newSegments;
            renderSegments();
        }

        function updateTranslation(segmentId, tgtLang, text) {
            const seg = segments.find(s => s.id === segmentId);
            if (seg) {
                if (!seg.translations) seg.translations = {};
                seg.translations[tgtLang] = text;
                renderSegments();
            }
        }

        function showSessionEnded() {
            sessionEnded = true;
            setStatus('Session ended', 'error');

            const notice = document.createElement('div');
            notice.className = 'ended-notice';
            notice.innerHTML = '<strong>Session Ended</strong>The recording has stopped. This transcript is preserved for your review.';
            transcript.appendChild(notice);
            requestAnimationFrame(() => {
                transcript.scrollTop = transcript.scrollHeight;
            });
        }

        function connect() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws/viewer/${token}`;

            setStatus('Connecting...', '');
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                setStatus('Connected', 'connected');
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);

                    if (data.type === 'init') {
                        if (data.status === 'waiting') {
                            // Session exists but recording hasn't started yet
                            setStatus('Waiting for session to start...', 'connected');
                        } else {
                            foreignLang = data.foreign_lang;
                            updateSegments(data.segments || []);
                            setStatus('Live', 'connected');
                        }
                    } else if (data.type === 'session_active') {
                        // Recording has started, we now have an active session
                        foreignLang = data.foreign_lang;
                        updateSegments(data.segments || []);
                        setStatus('Live', 'connected');
                    } else if (data.type === 'segments') {
                        if (data.foreign_lang && !foreignLang) {
                            foreignLang = data.foreign_lang;
                        }
                        updateSegments(data.segments || []);
                    } else if (data.type === 'translation') {
                        updateTranslation(data.segment_id, data.tgt_lang, data.text);
                    } else if (data.type === 'session_ended') {
                        showSessionEnded();
                    } else if (data.type === 'ping') {
                        // Respond to ping with pong
                        ws.send(JSON.stringify({ type: 'pong' }));
                    }
                } catch (e) {
                    console.error('Parse error:', e);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                setStatus('Connection error', 'error');
            };

            ws.onclose = (event) => {
                if (!sessionEnded) {
                    if (event.code === 4004) {
                        setStatus('Invalid or expired link', 'error');
                    } else {
                        setStatus('Disconnected', 'error');
                        // Try to reconnect after 3 seconds
                        setTimeout(connect, 3000);
                    }
                }
            };
        }

        // Start connection
        connect();
    </script>
</body>
</html>
